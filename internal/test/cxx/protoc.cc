// This mimicks the program in pbf_test.go using C++ code generated by protoc.

#include <algorithm>
#include <cmath>
#include <cstdint>

#include <unistd.h>

#include "test.pb.h"

using google::protobuf::RepeatedField;
using pbf::internal::test::Test;

#define CHECK(expr) do { if (!(expr)) return false; } while (0)

template <typename T>
static bool contains(const RepeatedField<T>& v, T needle)
{
	return std::find(v.begin(), v.end(), needle) != v.end();
}

static bool check_fields(const Test& m)
{
	CHECK(m.a() == 1);
	CHECK(m.b() != 1);
	CHECK(m.c() == 3);
	CHECK(m.d() < 0 && m.d() == m.d());
	CHECK(m.e() == -5);
	CHECK(m.f() < -5);
	CHECK(m.g() >= 0x7f000007);
	CHECK(m.h() <= 0x8000000000000008);
	CHECK(m.i() == float(M_PI));
	CHECK(m.j() == M_PI);
	CHECK(m.k() == "PBF");
	CHECK(m.l() == "Hello, world!" && m.l() == m.l());
	CHECK(m.m_size() >= 4 && m.m(3) == 4);
	CHECK(m.n().y() == 56789);
	CHECK(m.o().z_size() >= 1 && m.o().z(0) == -3);
	CHECK(m.p_size() >= 2 && m.p(1) == 20);
	CHECK(m.q_size() >= 3 && m.q(2).x() == 102);
	CHECK(m.s() == "");
	CHECK(contains(m.m(), uint64_t(4)));
	CHECK(contains(m.o().z(), int32_t(1)));
	CHECK(contains(m.t(), float(M_PI)));
	CHECK(contains(m.u(), double(M_PI)));
	return true;
}

__attribute__ ((noinline))
bool filter(Test& m, const uint8_t* buf, uint32_t size)
{
	if (!m.ParseFromArray(buf, size))
		return false;

	return check_fields(m);
}

int main()
{
	GOOGLE_PROTOBUF_VERIFY_VERSION;

	uint32_t size;
	auto n = read(STDIN_FILENO, &size, sizeof size);
	if (n != sizeof size)
		return 1;

	auto buf = new uint8_t[size];
	n = read(STDIN_FILENO, buf, size);
	if (int64_t(n) != int64_t(size))
		return 1;

	uint64_t count;
	n = read(STDIN_FILENO, &count, sizeof count);
	if (n != sizeof count)
		return 1;

	Test m;
	bool ok = false;

	for (uint64_t i = 0; i < count; i++) {
		ok = filter(m, buf, size);
		if (!ok)
			break;
	}

	uint8_t result = ok ? 1 : 0;
	n = write(STDOUT_FILENO, &result, sizeof result);
	if (n != sizeof result)
		return 1;

	return 0;
}
